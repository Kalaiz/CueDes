## ✍️ Reflection

- Package organisation - went with Packaging via feature after having a skim through [this](https://proandroiddev.com/package-by-type-by-layer-by-feature-vs-package-by-layered-feature-e59921a4dffa).
- Learned a few things about styles and themes. I learned it for the SwitchCompat, and made it such that it is red when unchecked and green when checked. 
- Tried to reduce redundant layout code for tabitem by using <include> however <include> only overwrite layout based attributes. Based on the [tabitem documentation.](https://stackoverflow.com/a/38035415/11200630), 3 attributes are provided for TabItem and they can be used alongside with the layout declaration. Note: This was done in a [previous commit](https://github.com/Kalaiz/cuedes/commit/ea31bfcb786067ffa28dced040e51d0cbedbb650) and other changes have overwritten this.
- One of the SwitchCompat was white in color despite applying a themeoverlay. A [unresolved SO post](https://stackoverflow.com/questions/59086466/after-migration-to-androidx-switchcompat-is-white) states that the OP had a similar issue as well. I made the MainActivity extend `AppCompactActivity` instead of `FragmentActivity` to overcome this problem.
- Learned about constraint weight, which help me achieve layout suitable for different device size. I faced a challenge in which i needed to place an image with a width of 1/3rd the screen width. I wanted to do this declaritively instead of programmatically. I eventually managed to do this by having a linear layout within which i placed the image alongside with a void ( used view instead of space as space is deprecated) Note: This was done in a [previous commit](https://github.com/Kalaiz/cuedes/commit/f5a7a24c2c6ecdc346edb08e056b9d32236fe005#diff-bf8d963c7dff2838dfdf67e3fb793dd0e1129414d7bfd936191b0eb2a0dd743a) and other changes have overwritten. This is not in use. I also learned that I do not need a extra layout and could have simply used guidelines, as a way to flatten the view hierarchy. **16/03** Got to know that the width and height can be directly constraint by a percentage via [`layout_constraintWidth_percent`](https://android.jlelse.eu/whats-new-in-constraint-layout-1-1-0-acfe30cfc7be#5ec6:~:text=width%20and%20height%20can%20be%20defined,percentage%20by%20using%20layout_constraintWidth_percent%20and%20layout_constraintHeight_percent.)( Height as well) and have used it to replace some dimen for various device size.
- In order to hide my Google Map SDK API key, I had to encapsulate key in a gradle property file and then acccess it via meta data created by the app level gradle build. By default, the repo will not contain the API key, thus affecting the installation APK. In order to overcome this, I un-ignored the apk file created in gitignore and have linked it in the Installation instruction.
- Got to know about the existence of bottomNavigationView, although I had already achieved a similar result using a tablayout.I changed it to a BottomNavigationView as it allow the [navigation bar to disappear on scroll, based on `HideBottomViewOnScrollBehavior`, when it is placed within a CoordinatorLayout and one of the children within the CoordinatorLayout is scrolled](https://developer.android.com/reference/com/google/android/material/bottomnavigation/BottomNavigationView). 
- I had to make sure the application rings an alarm even when the user is not interacting with the application. This seemed like a long running task  which  1) constantly check the location 2) use that location to check whether it is going to cause an alarm. I went with [Services](https://developer.android.com/guide/components/services) in order to achieve this. I also needed to gain information about the location so that the application is informed as well and hence went with a bound service. By making it a bound service, the service will run as long 
- I was going with MVVM architecture, however I was confused on which level would Services would be placed.[TODO]
- The default positioning of the current location button is being overlapped by my `SearchView`. In order to overcome this, I tried a [recomendation](https://stackoverflow.com/a/43971145/11200630) of setting padding, however, this makes the location to be at a offset from the center of the screen. I also tried to [manually set](https://stackoverflow.com/a/48277931/11200630) the `LayoutParams` of the button, howvever, upon clicking it, nothing happens. Eventually, I made my own current location button using `FusedClientLocation` API and used `animateCamera` and `CameraUpdate` in accordance.
- Learned that [`Shape`](https://stackoverflow.com/a/50619479/11200630) s/ [`ShapeDrawable`](https://developer.android.com/guide/topics/graphics/drawables#shape-drawable) s can be applied to a `View`'s background, so to make the `View` of the relevant shape, while attempting to get rounded corners for my `BottomSheetDialogFragment`.
- I have used Fragments which uses the same container, in `selection`. Fragments sharing the same container will have to replace one another or else they will overlap each other.To avoid this, I simply hide the previous fragment and show the relevant fragment upon `popBackStack`.
- While implementing the `OnBoardFragment`, I wanted to access the page indication `View` so to disable it when the user has'nt given relevant permission. However, the `OnBoardFragment`,which  extends [`OnboardingSupportFragment()`](https://developer.android.com/reference/androidx/leanback/app/OnboardingSupportFragment), has limited accessibility to all of it's `View`. In order to overcome this, I dug into the `@style/Theme.AppCompat.Leanback.Onboarding` and tried to see possible `View ID` for the page indication `View`, and found that `androidx.leanback.R.id.page_indicator` to be the suitable one. **Note**: I later found that there is an easier way to this via the [runtime layout inspector](https://developer.android.com/studio/debug/layout-inspector#layout-inspector).
- As I was working on integrating the device permission requests to the `OnBoardFragment`, I found the [official documentation](https://developer.android.com/reference/androidx/core/app/ActivityCompat#shouldShowRequestPermissionRationale(android.app.Activity,%20java.lang.String)) on `shouldShowRequestPermissionRationale`, stating that it should be called before requesting permission, meanwhile the [official guide](https://developer.android.com/training/permissions/requesting#explain), stating that it should be called after the relevant permission is being denied. This confused me on the usage of the method and how it functions in different scenarios. With the help of a [SO post](https://stackoverflow.com/a/34612503/11200630), I understood that `shouldShowRequestPermissionRationale` returns false if the user has selected Never ask again or when the device prohibits the app from having that permission (Example: [In Android 11, multiple deny equal to "don't ask again"]((https://developer.android.com/training/permissions/requesting#handle-denial))). Additionally, this method returns false as well, if the user has  never been asked for the permission as well.
- In order for `FusedProviderLocationClient` to work, Google Location Services had to be enabled. I did not realised this until I found that my `getLastLocation` were returning null, when tested on a mint emulator. Usually, phones which have accessed Google Maps previously would not face an issue. Hence, in order to cover for such phones I requested the relevant permission via [`SettingClient`](https://developers.google.com/android/reference/com/google/android/gms/location/SettingsClient) during the onBoarding process.
- `startResolutionForResult` of PlayServices API, when used from a fragment, did not call `onActivityResult` of the fragment, despite the fragment calling `super.onActivityResult()`. I am not sure why it didn't call. I felt that this issue seemed similar with this SO [post](https://stackoverflow.com/a/6147919/11200630), where in my case the API was calling `activity.startIntentSenderForResult`( I skimmed through the implementation). I overcame this issue by ~~manually calling each fragment's `onActivityResult` in the host activity's `onActivityResult`.~~  using `startIntentSenderForResult` instead based on this [answer](https://stackoverflow.com/a/52159667/11200630).
- I wanted to dismiss the `SelectionFragment` from it's child fragment. I had planned to have them in the same package, and assign a package private visibility levelled `Fragment` Tag so to access the fragment via the tag. However, I learned that there [isn't](https://discuss.kotlinlang.org/t/kotlin-to-support-package-protected-visibility/1544/108) a direct way in which package private visibilty could be achieved. I overcame this by via setting a listener on the backstack of `SelectionFragment` and then dismissing itself if the back stack is 0. 
- As I imported jetpack navigation component dependencies, I was notified by the IDE that `onActivityResult`, `requestPermission` and the relateds were deprecated and the use of the new Activity Result API is recommended. I had to refactor some parts of the existing implementation to accomodate the changes.
- To pass on data from a fragment to another fragment  I made use of `setFragmentResultListener()`. However, it was like a one way transmission. Hence, I made use of a shared Viewmodel, which allowed me to do 2 way communication.

- ~~My `OnBoardFragment` extends `OnBoardSupportFragment` which provides animations of titles, description etc by default. However, I am currently showing and hiding `View`s so to accomodate content (Initially, when I planned of the onboarding process, I didnt account for/expect it to scale up). I realise that this **does not scale** up very well. I could replace with 1) multiple fragments, Jetpack Navigation Component ( will provide animations as well) or 2) Current Implementation(Instead of showing and hiding views) + `ViewPager` + `Fragment`.   `MotionLayout` could be used to enchance the visual effect(optional)~~ **26/12:** Transferred to the use of (2) w/o MotionLayout. In the end, I felt that I could have gone with a custom fragment for the onboarding process, instead of using `OnBoardSupportFragment`, due to it's inflexibilty being an issue.

- I have used `MotionLayout` for my `LocationFragment`, which resizes the map fragment and the selection fragment accordingly. However, I noticed that the map fragment was flickering on low end devices. Upon using the [GPU profiler](https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering), I noticed that when the flickering happens , significant amount of time is spent on `onLayout` and `onMeasure` callbacks. Also, I noticed that the map was loading whenever the camera view is being moved, and my implementation( does a `CameraUpdate` and then immediately followed by an "split screen animation") did not account for this. I resolved ( to an extent) this by not doing any `CameraUpdate` while resizing the map view.

- The `SelectionFragment` which has multiple child fragments ( `LocationNameFragment`,`RadiusFragment`,`NotificationMethodFragment` ) are merged into a single fragment, as I felt that it speedens up the process of setting an alarm. 
- Learned about RecyclerView DiffUtil from this [codelab](https://developer.android.com/codelabs/kotlin-android-training-diffutil-databinding#1). TODO - I'll need to expand later.

- Learned that `Button` has a default margin. Tried to override it using this [solution](https://stackoverflow.com/a/43298421/11200630) which overrides the default background. However, the button's drawable's size [cannot](https://stackoverflow.com/questions/32656837/changing-the-drawable-size-inside-a-button) be changed.I eventually made my own button using a LinearLayout.

- I was searching for various Place autocompletion APIs, however most of them were limited and were not free. I am planning to use wikipedia API to search for locations. -- TODO


-  Polling location periodically  and expanded "configuration" of geofencing request since sometimes geofencing fails to trigger.

### What I could have done better/will be doing

- In regards to `entry` package, I need to follow MVVM, logic is currently tangled with the views and can be transferred  to the viewmodel. **15/02** Planning to use Jetpack Navigation for onBoarding. 
- Segregate logic in `locationViewModel` into models such as `AlarmMapManager` and `CameraManager`.
- Implement Settings and various other mode of notification.
- Testing
- I could have used dependency injection.


[:arrow_backward: Back](https://github.com/Kalaiz/cuedes#%EF%B8%8F-reflection)
